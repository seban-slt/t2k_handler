	opt	h+

; equtes

BLK_WRITE	equ	0
BLK_READ	equ	1

; zero page

byte		equ $30
sum		equ $31
ad0		equ $32
ad1		equ $34
ad2		equ $cb		; $43 <-- don't use destroyed by other channel (disk access)
erc		equ $49

buf		equ $d800	; buffer location for one t2k record (3072 / $0c00 bytes)

; direct system calls

putc		equ $f2b0
bell		equ $f556
get_key		equ $f2f8

; copy ROM to RAM under ROM

	org	 $0600

rom2ram	ldy	 #$00
	ldx	 #$c0
	sty	 ad2
	stx	 ad2+1
	inc	 $d40e
	sei
rr0	lda	 (ad2),y
	dec	 $d301
	sta	 (ad2),y
	inc	 $d301
	iny
	bne	 rr0
	inc	 ad2+1
	beq	 ext
	lda	 ad2+1
	cmp	 #$d0
	bne	 rr0
	lda	 #$d8
	sta	 ad2+1
	bne	 rr0
ext	dec	 $d301
	dec	 $d40e
	cli
	rts

	ini	rom2ram

	org	$0600

vtab	dta	a(opn-1),a(cls-1),a(gtx-1),a(ptx-1)
	dta	a(n_impl-1),a(n_impl-1)
	jmp	n_impl
	brk

opn	jsr	rom_dis
	jsr	open
	jmp	rom_ena

cls	jsr	rom_dis
	jsr	clos
	jmp	rom_ena

gtx	jsr	rom_dis
	jsr	get
	jmp	rom_ena

ptx	jsr	rom_dis
	jsr	put
	jmp	rom_ena
n_impl	rts

rom_ena	pha
	lda	$d301
	ora	#1
	bne	setp

rom_dis	pha
	lda	$d301
	and	#$fe
setp	sta	$d301
	pla
	rts

;key	jsr	rom_ena
;	jsr	rom_get_key
;	jmp	rom_dis

start	ldx	<ini_dev
	ldy	>ini_dev
	stx	$2
	sty	$3
	lda	$9
	ora	#2
	sta	9

ini_dev	ldx	#'T'
	ldy	<vtab	
	lda	>vtab
	jsr	$e486		; install new devie handler
	bcc	*+5
	jmp	bell
	rts

; process given filename (with skipping colons)
;
; e.g. " T:FOO.BAR" --> "FOO.BAR"
;      "T1:FOO.BAR" --> "FOO.BAR"
;

prcs_fn	ldx	#0
	ldy	#1

	lda	#':'	
c_src	cmp	($24),y
	beq	c_fnd
	iny
	cpy	#3
	bcc	c_src	
	ldy	#1
c_fnd	iny

c_cpy	lda	($24),y
	sta	fname,x
	cmp	#$9b
	beq	c_skp
	iny
	inx
	cpx	#12
	bcc	c_cpy
c_skp	lda	#$20
	sta	fname,x
	inx
	cpx	#12
	bcc	c_skp
	rts
	
fname	org	*+$10

	org $cc00

dly	dex			; PWM pulse delay loop
	bne	 *-1
	rts

; pulse write subroutine
; 
; in: Y reg. --> pulse type

pcm	ldx	tw+0,y		; get 1st half of pulse len from lookup table
	jsr	dly

	lda	#$00		; start of pulse
	sta	$d300

	lsr	$d01a		; set background color

	bit	$d20e		; check BREAK key
	bpl	break

	ldx	tw+1,y		; get 2nd half of pulse len from lookup table
	jsr	dly

	lda	#$40		; end of pulse
	sta	$d300
	sta	$d01a		; set background color
	rts

break	ldy	#$80		; handle break KEY
	jmp	on

; write byte routine
;
; in: A reg. --> byte to write

pbt	ldx	#8		; load loop counter (8 bits per byte)
	stx	byte

by0	asl	@		; shift out next bit in carry
	pha			; save A reg.

	ldy	 #$00		; sel. pulse type for logic "0"
	bcc	 *+4
	ldy	 #$02		; sel. pulse type for logic "1"

	jsr	 pcm		; write pulse

	pla			; restore A reg.
	dec	 byte		; decr. bit counter
	beq	 bt_done	; exit when done!

	ldx	 #$0c		; compensate loop delay
	jsr	 dly
	jmp	 by0		; next bit!

bt_done	rts

; get byte routine
;

gbt	ldx	#8		; X rag. will be bit-loop counter

ge0	bit	$d20e		; check break KEY
	bpl	break

	lda	#$80
	bit	$d300		; check input bit state
	bne	ge0		; wait for falling edge

	inc	$d01a		; set background color

	ldy	#0		; clear cycle counter

ge1	iny			; incr. Y reg.
	bmi	 e140		; >127, pulse error (to long)

	bit	 $d300		; check input bit state again
	beq	 ge1			; wait for end of pulse (next rising edge)

	lsr	 $d01a		; change background color

	cpy	 tw+6		; compare pulse len with lookup
	bcs	 er		; longer than sync duration?

	lsr	erc		; clear "sync pulse allowed" flag

	cpy	 tw+7		; compare with logic "1" duration

	rol	 byte		; shit in the carry bit into byte

	dex			; decr. loop counter
	bne	 ge0		; loop till all bits read
	rts

er	bit	 erc		; check if sync sequence broken
	bmi	 ge0		; when broken, throw error

e140	ldy	 #$8c		; load error #140 into reg. Y
	jmp	 on		; error thrown, restore state.

; prepare for block read/write

off	sei			; disable IRQ
	inc	$d40e		; disable NMI
	lda	$d40b
	bne	*-3		; wait for scanline #0
	sta	$d400		; turn off the ANTIC DMA
	sta	sum		; clear CKSUM

	lda	#%001111000	; motor off + DIR reg. select
	sta	$d302

	lda	#%01100000	; setup PORTA I/O direction (bits #5 & #6 as outputs)
	sta	$d300

	lda	#%00110100	
	sta	$d302		; turn motor on
	sta	$d303		; enable CMD line (activate turbo interface in SIO mode)

; old KSO setup
;	lda	 #$38
;	sta	 $d302
;	lda	 #$60
;	sta	 $d300
;	lda	 #$3c
;	sta	 $d302

	tsx			; get stack pointer
	inx
	inx
	stx	 psp+1		; and store it in code (needed @ return)	
	rts

; write block subroutine

wblk	jsr	 off		; prepare for write (setup ports, enable turbo interface, motor on)

; write out the sync-tone

	lda	 #0		; setup inner loop counter (0 == 256)
	sta	 byte
	ldy	 #$08		; setup outer loop counter (8*256 = 2048 sync pulses)
s0	tya
	pha
	ldy	 #4
	jsr	 pcm
	pla
	tay
	dec	 byte
	bne	 s0		; inner loop
	dey
	bne	 s0		; outer loop

	lda	 #0		; init source data pointer
	ldy	 ad0	
	sta	 ad0		; (use Y as Lo-Byte, for faster and smaller code below)

	ldx	 #2		; compesate delay
	jsr	 dly

noen	tya			; save Y reg. o stack (lo-byte of src data pointer)
	pha

	lda	 (ad0),y	; get current byte
	pha			; save on stack

	clc			; calculate checksum
	adc	 sum
	sta	 sum

	pla			; restore A reg.
	jsr	 pbt		; write out the byte i A reg.

	pla			; restore Y reg.
	tay

	iny			; increment src data pointer
	bne	 *+4
	inc	 ad0+1

	cpy	 ad1		; compare with end of data segment address
	lda	 ad0+1
	sbc	 ad1+1
	bcc	 noen		; repeat until end of data segment address

	lda	 sum		; load checksum byte

	ldx	 #$01		; compensate delay
	jsr	 dly

	jsr	 pbt		; write out the checksum byte

	ldy	 #$01		; status $01 (all OK) in Y reg.
	jmp	 on		; stop the motor, restore state

br0	jmp	 break		; jump to BREAK key handler (to avoid out of range BMI jump below)

; get block

gblk	jsr	 off		; pepare for read (port init, motor on, enable turbo interface)

	lda	 #$ff		; init sync seq detectenion flag
	sta	 erc

wx	ldy	 #0
w0	ldx	 #$00

w1	lda	 $d20e		; check BREAK key
	bpl	 br0		; jump out when pressed

	lda	 #$80
	bit	 $d300
	bne	 w1

	inc	 $d01a

w2	inx
	bmi	 w0
	bit	 $d300
	beq	 w2

	lsr	 $d01a
	cpx	 #$36
	bcc	 wx
	iny
	bne	 w0

	lda	 #0
	ldy	 ad0
	sta	 ad0
w3	tya
	pha
	jsr	 gbt
	pla
	tay
	lda	 byte
	sta	 (ad0),y
	clc
	adc	 sum
	sta	 sum
	iny
	bne	 *+4
	inc	 ad0+1
	cpy	 ad1
	lda	 ad0+1
	sbc	 ad1+1
	bcc	 w3
	jsr	 gbt

	ldy	 #$8f
	lda	 byte
	cmp	 sum
	bne	 on

	ldy	 #$30
	sty	 $d01a
op	sta	 $d40a
	dex
	bne	 op
	dey
	bne	 op
	iny

on	lda	 $d40b
	bne	 *-3		; wait for scanline #0

	lda	 $22f		; restore ANTIC DMA
	sta	 $d400

psp	ldx	 #0
	txs

	lda	#%00111000	; motor-off + DIR reg. select
	sta	$d302		; setup PACTL

	lda	#0		; restrore all PORTA pins as inputs 
	sta	$d300
	
	lda	#%00111100	; motor off + DATA reg. select
	sta	$d302
	sta	$d303		; and deactivate CMD line (disable turbo interface in SIO mode)

; old KSO setup
;	lda #$38
;	sta $d302
;	lda #$00
;	sta $d300
;	lda #$3c
;	sta $d302

	lda #$40		; restore NMI
	sta $d40e
	cli			; restore IRQ
	rts

blk_rw	stx ad1
	sty ad1+1
	ldx <buf
	ldy >buf
	stx ad0
	sty ad0+1
	tax
	bne *+5
	jmp wblk
	jmp gblk


open	lda #$00
	sta stat
	lda $2a

;	don't mask any bits, this will allow to throw an error when somebody try to to DIR on T: device
;	and #$0c	

	cmp #4
	beq opr
	cmp #8
	beq opw
	ldy #$92
	rts

opw	ldx <buf
	ldy >buf
	jsr name
	lda #BLK_WRITE
	ldx <buf+$0c
	ldy >buf+$0c
	jsr blk_rw
	jsr init
	tya
	bmi err
	lda #$80
	dta b($2c)	; bit $xxxx
err	lda #$00
	sta stat
	rts

opr	lsr hlp
next	lda #BLK_READ
	ldx <buf+$0c
	ldy >buf+$0c
	jsr blk_rw
	cpy #$80
	beq err
	tya
	bmi next
	ldx <nn
	ldy >nn
	jsr name
	ldx #0
dal	lda nn,x
	cmp #'?'	; skip to next char
	beq o0

	cmp #'*'	; when * detected, display prompt, ask user what to do!
	beq sel
	cmp #'/'	; for BW-DOS compatibility (* in BW-DOS copy routine forces reading the disk DIRECTORY)
	beq sel

	cmp #'@'
	beq ok
	cmp buf,x
	bne next

o0	inx
	cpx #$0c	; all chars from filename checked?
	bne dal

ok	jsr init
	ldy #$01
	sty stat
	rts
sel	ldx #2
se0	txa
	pha
	lda buf,x
	jsr putc
	pla
	tax
	inx
	cpx #$0c
	bcc se0
	ldx #0
se1	txa
	pha
	lda tn,x
	jsr putc
	pla
	tax
	inx
	cpx #8
	bne se1
	jsr get_key
	and #$5f
	ora #$40
	cmp #'T'
	php
	beq *+4
	lda #'N'
	jsr putc
	lda #$9b
	jsr putc
	plp
	bcs ok
	jmp next

clos	lda stat
	bpl cod
	lda #0
	ldy ad2
	sta ad2
z0	lda #0
	sta (ad2),y
	iny
	bne *+4
	inc ad2+1
	cpy <buf+$0c02
	lda ad2+1
	sbc >buf+$0c02
	bcc z0
	lda #BLK_WRITE
	ldx <buf+$0c02
	ldy >buf+$0c02
	jsr blk_rw
cod	ldy #$01
	rts

put	ldy stat
	bmi *+5
	ldy #$87
	rts
	ldy #0
	sta (ad2),y
	inc ad2
	bne *+4
	inc ad2+1
	inc buf
	bne p0
	inc buf+1
	lda buf+1
	cmp #$0c
	beq cont
p0	ldy #1
	rts

cont	lda #BLK_WRITE
	ldx <buf+$0c02
	ldy >buf+$0c02
	jsr blk_rw
	tya
	bpl *+5
br1	jsr err
	jmp init

get	ldy stat
	dey
	beq gt0
	ldy #$83
	rts
gt0	lda buf
	ora buf+1
	bne rnb
	lda hlp
	bpl nb
	ldy #$88
	rts
nb	lda #BLK_READ
	ldx <buf+$0c02
	ldy >buf+$0c02
	jsr blk_rw
	jsr ini1
	tya
	bmi br1
	lda buf+1
	cmp #$0c
	beq rnb
	sec
	ror hlp
	bne gt0
rnb	ldy #0
	lda (ad2),y
	inc ad2
	bne *+4
	inc ad2+1
	ldy buf
	bne *+5
	dec buf+1
	dec buf
	ldy #1
	rts


init	lda #$00
	sta buf+0
	sta buf+1
ini1	lda <buf+2
	sta ad2
	lda >buf+2
	sta ad2+1
	rts

name	stx ad0
	sty ad0+1
	jsr prcs_fn
	ldy #1
n0	lda nn,y
	sta (ad0),y
	dey
	bpl n0
	ldx #0
	ldy #2
n1	lda fname,x
	cmp #$9b
	beq n2
	cmp #'?'
	beq n2
	sta (ad0),y
	inx
	iny
	cpy #$0c
	bcc n1
	rts
n2	lda #$20
n3	sta (ad0),y
	iny
	cpy #$0c
	bcc n3
	rts

tw	dta b($0d),b($21),b($35),b($49),b($91),b($99)
	dta b($36),b($1b)

tn	dta c' [T/N] ?'
stat	brk
hlp	brk
nn	dta b($00),b($ff)

	ert	*>$d000

	run start

	end of handler
